# Used Threads 
1. UI_thread(main) => It controls the UI exploring or updating. 

2. flow_control_thread 	=> It controls the calibration process, where is polling and keyboard. The initial pollings(e.g. CANBUS & MODBUS) threads will be created here.

	> The two threads communicate with each other via global variables now. (The mutex should be considered).

# Compile
Switch the content in "compile.sh", it will compile "UI_layout_main.c" or "Cali.c"
1. "UI_layout_main.c" 	=> executable file named 'a' => be compiled goes with keyboard_thread in "UI_layout.c".
2. "Cali.c" 			=> executable file named 'b' => be compiled goes with flow_control_thread "UI_layout.c".

# Feature :
1. "UI" will not block the keyboard.
2. After pressing(not rotate) the "knob", UI_thread update the label of adjustment_mode
3. This version uses app form to launch the whole process including UI and exe.

4. './a' file : after press button, the keyboard_thread runs.
5. './b' file : after press button, the Cali process runs. 
	> The pthread created in "UI_layout.c => on_activate()" impact which function is being compiled.

# To-do:
1. Combine to Cali.c
2. Get the calibration type and show it on the screen (perhaps, we can put some fake data to frame.data[2..7])
3. Get the communication interface and show it on the screen (Read "communication_found")




